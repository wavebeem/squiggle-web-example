let h = require("virtual-dom/h")
let diff = require("virtual-dom/diff")
let patch = require("virtual-dom/patch")
let createElement = require("virtual-dom/create-element")

let String = global.String
let Object = global.Object
let document = global.document
let body = document.body

def unicode(codepoint) =
    String.fromCharCode(parseInt(codepoint, 16))

let CHAR_EMPTY = unicode("B7")
let CHAR_PLAYER = "@"

def rangeDo(a, b, f) =
    if a < b
        then do
            f(a);
            rangeDo(a + 1, b, f);
        end
        else undefined

def rangeMap(a, b, f) =
    freezeAfter(Array(), fn(xs)
        rangeDo(a, b, fn(i) xs.push(f(i))))

def hashCoord(x, y) =
    [x, y].join(",")

def makeRoom(w, h) =
    freezeAfter(Object(), fn(room) do
        rangeDo(0, w, fn(x)
            rangeDo(0, h, fn(y)
                set(hashCoord(x, y), undefined, room)
            )
        );
        set("width", w, room);
        set("height", h, room);
    end)

let model = {
    x: 0,
    y: 0,
    blink: false,
    room: makeRoom(40, 20)
}

def classes(cs) =
    # Ugh, fix this parse issue.
    (filter(cs, Boolean)).join(" ")

def renderCell(x, y, model, occupant) =
    let t = occupant.type
    let c = if t == "Player"
        then CHAR_PLAYER
        else CHAR_EMPTY
    let cs = classes([
        "game-cell",
        "has-" ++ t.toLowerCase(),
        if model.blink and t == "Player"
            then "is-blinking"
            else ""
    ])
    in h("td", {className: cs}, [c])

def renderedCellsFor(model) =
    let W = model.room.width
    let H = model.room.height
    in rangeMap(0, H, fn(y)
        h("tr.game-row",
            rangeMap(0, W, fn(x)
                let occupant = {
                    type: if x == model.x and y == model.y
                        then "Player"
                        else "Empty"
                }
                in renderCell(x, y, model, occupant)
            )
        )
    )

def render(model) =
    h("main", [
        h("table.game-view",
            h("tbody", renderedCellsFor(model))
        ),
        h("div.game-log", [Date()])
    ])

def updateAnimations(model) =
    model ~ {blink: not model.blink}

def update(model, event) =
    match event.type
    case "Tick" => updateAnimations(model)
    case "Key" => handleKey(model, event.code)
    end

let app = Object()

def tick() =
    let newModel = update(app.model, {type: "Tick"})
    in do
        set("model", newModel, app);
        updateView();
        setTimeout(tick, 300);
    end

def updateView() =
    let newTree = render(app.model)
    let patches = diff(app.tree, newTree)
    let newRoot = patch(app.rootNode, patches)
    in do
        set("rootNode", newRoot, app);
        set("tree", newTree, app);
    end

def handleKeyPress(event) =
    let message = {type: "Key", code: event.which}
    let newModel = update(app.model, message)
    in do
        set("model", newModel, app);
        updateView();
    end


let K = {
    W: 119,
    A: 97,
    S: 115,
    D: 100
}

def handleKey(model, code) =
    let delta = match code
        case (K.W) => {y: model.y - 1}
        case (K.A) => {x: model.x - 1}
        case (K.S) => {y: model.y + 1}
        case (K.D) => {x: model.x + 1}
    end
    in model ~ delta

def start() =
    let tree = render(model)
    let rootNode = createElement(tree)
    in do
        set("model", model, app);
        set("rootNode", rootNode, app);
        set("tree", tree, app);
        body.appendChild(rootNode);
        body.addEventListener("keypress", handleKeyPress);
        tick();
    end

in start()
